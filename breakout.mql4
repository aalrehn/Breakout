//+------------------------------------------------------------------+
//| Engulfing EA with RSI Divergence + Invalidation                  |
//+------------------------------------------------------------------+
#property strict

datetime lastCheck = 0;
input int RSI_Period = 14;
datetime alerts[];

input int    LookbackBars         = 50;   
input int    MaxBreakoutScanBars  = 100;  

input bool   EnableAlerts         = true;
input color  BreakoutLineColor    = Lime; 
input color  EngulfLineColor      = Black; 
input color LineColor = Lime;
int onInit(){
   ArrayResize(alerts, 0);
   return(INIT_SUCCEEDED);
}
void OnTick()
{
    
   if (Time[1] == lastCheck) return;
   lastCheck = Time[1];
  checkBreakouts();
   for (int i = 30; i >= 10; i--)
   {
   

      if (IsBearishEngulfing(i))
      {
         double engulfHigh = High[i];


         for (int j = i - 1; j >= i - 20 && j > 0; j--)
         {
            if (Close[j] > engulfHigh)
            {
               if(!IsAlertSent(Time[j])){
               string name = "EngulfInvalid_" + TimeToStr(Time[j], TIME_SECONDS);
               DrawBlackLine(name, Time[j]);
               Alert("Bearish Engulfing Invalidated at ", Symbol(), " on ", TimeToStr(Time[j]));
               AddAlert(Time[j]); 
               break;
               }
            }
         }
      }


      if (IsBullishEngulfing(i) && HasBullishRSIDivergence(i))
      {
                        if(!IsAlertSent(Time[i])){
         string name = "BullishRSIEngulf_" + TimeToStr(Time[i], TIME_SECONDS);
         DrawBlackLine(name, Time[i]);
         Alert("Bullish Engulfing with RSI Divergence at ", Symbol(), " on ", TimeToStr(Time[i]));
                        AddAlert(Time[i]); 
         }
      }
   }
}

bool IsAlertSent(datetime time)
{
   int size = ArraySize(alerts);
   for (int i = 0; i < size; i++)
   {
      if (alerts[i] == time)
         return true;
   }
   return false;
}

void AddAlert(datetime time)
{
   int size = ArraySize(alerts);
   
   if (size >= 1000)
   {
  
      int newSize = size / 2;
      for (int i = 0; i < newSize; i++)
      {
         alerts[i] = alerts[i + newSize];
      }
      ArrayResize(alerts, newSize);
      size = newSize;
   }
   
   ArrayResize(alerts, size + 1);
   alerts[size] = time;
}
void checkBreakouts()
{

   for (int i = 1; i < Bars; i++)
   {
      if (i + 1 >= Bars) 
         continue;
      
      double priorSupport = Low[i + 1];
      for (int j = i + 1; j < Bars; j++)
      {
         if (Low[j] < priorSupport)
            priorSupport = Low[j];
      }
      // horizontal on close
      

      if (Low[i] < priorSupport && Close[i - 1] > High[i])
      {
         datetime rejectTime = Time[i - 1];
         if (!IsAlertSent(rejectTime))
         {
            string msg = "Breakout" + Symbol() + " at " + TimeToStr(rejectTime, TIME_DATE | TIME_MINUTES);
            if (EnableAlerts)
               Alert(msg);
            Print(msg);
            ClearPreviousBreakoutLines();
            string lineName = "PatternLine_" + TimeToString(Time[i], TIME_MINUTES | TIME_SECONDS);
            ObjectCreate(0, lineName, OBJ_HLINE, 0, 0, Close[i-1]);
            ObjectSetInteger(0, lineName, OBJPROP_COLOR, Red);
            ObjectSetInteger(0, lineName, OBJPROP_WIDTH, 2);
            ObjectSetInteger(0, lineName, OBJPROP_STYLE, STYLE_SOLID);
            


            AddAlert(rejectTime);
         }
         break;
      }
   }
}
   
   
   
//-----------------------
// Pattern Detection
//-----------------------

bool IsBearishEngulfing(int i)
{
   if (i + 1 >= Bars) return false;

   return (
      Close[i] < Open[i] &&                       // current candle is bearish
      Close[i + 1] > Open[i + 1] &&               // previous candle is bullish
      High[i] >= High[i + 1] + Point * 2 &&       // high fully engulfs
      Low[i] <= Low[i + 1] - Point * 2 &&         // low fully engulfs
      Close[i] < Low[i + 1] - Point * 2           // closes below prior candle's low
   );
}

bool IsBullishEngulfing(int i)
{
   if (i + 1 >= Bars) return false;

   return (
      Close[i] > Open[i] &&                       // current candle is bullish
      Close[i + 1] < Open[i + 1] &&               // previous candle is bearish
      Low[i] <= Low[i + 1] - Point * 2 &&         // low fully engulfs
      High[i] >= High[i + 1] + Point * 2 &&       // high fully engulfs
      Close[i] > High[i + 1] + Point * 2          // closes above prior candle's high
   );
}

bool HasBullishRSIDivergence(int i)
{
   if (i + 5 >= Bars) return false;

   double currentLow = Low[i];
   double prevLow = Low[i + 5];

   double rsiCurrent = iRSI(NULL, 0, RSI_Period, PRICE_CLOSE, i);
   double rsiPrev = iRSI(NULL, 0, RSI_Period, PRICE_CLOSE, i + 5);

   return (
      currentLow < prevLow - Point * 2 &&   
      rsiCurrent > rsiPrev + 0.1            
   );
}

//-----------------------
// Draw Helper
//-----------------------

void DrawBlackLine(string name, datetime time)
{
      DeleteAllLines();
   if (ObjectFind(0, name) < 0)
   {
      ObjectCreate(0, name, OBJ_VLINE, 0, time, 0);
      ObjectSetInteger(0, name, OBJPROP_COLOR, clrBlack);
      ObjectSetInteger(0, name, OBJPROP_WIDTH, 2);
   }
}
void ClearPreviousBreakoutLines()
{
   for (int i = ObjectsTotal() - 1; i >= 0; i--)
   {
      string name = ObjectName(i);
      if (StringFind(name, "PatternLine_") >= 0 || StringFind(name, "PatternLine_") >= 0)
         ObjectDelete(0, name);
   }
}


void DeleteAllLines()
{

   for(int i = ObjectsTotal() - 1; i >= 0; i--)
   {
      string objName = ObjectName(i);
      if(StringFind(objName, "EngulfInvalid_") >= 0 || 
         StringFind(objName, "BullishRSIEngulf_") >= 0
       )
      {
         ObjectDelete(0, objName);
      }
   }
}
