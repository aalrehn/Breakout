//+------------------------------------------------------------------+
//| Engulfing EA with RSI Divergence + Invalidation                  |
//+------------------------------------------------------------------+
#property strict

datetime lastCheck = 0;
input int RSI_Period = 14;
datetime alerts[];

input int    LookbackBars         = 50;   
input int    MaxBreakoutScanBars  = 100;  
input int    MaxSupportLookback   = 50;  

input bool   EnableAlerts         = true;
input color  BreakoutLineColor    = Lime; 
input color  EngulfLineColor      = Black; 
input color LineColor = Lime;
int onInit(){
   ArrayResize(alerts, 0);
   return(INIT_SUCCEEDED);
}

string TimeframeToString()
{
   int tf = Period();
   switch(tf)
   {
      case 1:     return "M1";
      case 5:     return "M5";
      case 15:    return "M15";
      case 30:    return "M30";
      case 60:    return "H1";
      case 240:   return "H4";
      case 1440:  return "D1";
      case 10080: return "W1";
      case 43200: return "MN1";
      default:    return "M" + IntegerToString(tf);
   }
}
void OnTick()
{
    
   if (Time[1] == lastCheck) return;
   lastCheck = Time[1];
  checkBreakouts();
   for (int i = 30; i >= 10; i--)
   {
   

      if (IsBearishEngulfing(i))
      {
         double engulfHigh = High[i];


         for (int j = i - 1; j >= i - 20 && j > 0; j--)
         {
            if (Close[j] > engulfHigh)
            {
               if(!IsAlertSent(Time[i])){
                           AddAlert(Time[i]); 
               string name = "EngulfInvalid_" + TimeToStr(Time[j], TIME_SECONDS);
               DrawBlackLine(name, Time[j]);
               Alert("Bearish Engulfing Invalidated at ", Symbol(), " on ", TimeToStr(Time[j]));
                     SendNotification("Bearish Engulfing Invalidated at " + Symbol() + " " + TimeframeToString() + " on " + TimeToStr(Time[i]));
   
               break;
               }
            }
         }
      }


      if (IsBullishEngulfing(i) && HasBullishRSIDivergence(i))
      {
                        if(!IsAlertSent(Time[i])){
                        AddAlert(Time[i]); 
         string name = "BullishRSIEngulf_" + TimeToStr(Time[i], TIME_SECONDS);
         DrawBlackLine(name, Time[i]);
         Alert("Bullish Engulfing with RSI Divergence at ", Symbol(), " on ", TimeToStr(Time[i]));
           SendNotification("Bullish Engulfing with RSI Divergence at " + Symbol() + " " + TimeframeToString() + " on " + TimeToStr(Time[i]));
                        
         }
      }
   }
}

bool IsAlertSent(datetime time)
{
   int size = ArraySize(alerts);
   for (int i = 0; i < size; i++)
   {
      if (alerts[i] == time)
         return true;
   }
   return false;
}

void AddAlert(datetime time)
{
   int size = ArraySize(alerts);
   
   if (size >= 1000)
   {
  
      int newSize = size / 2;
      for (int i = 0; i < newSize; i++)
      {
         alerts[i] = alerts[i + newSize];
      }
      ArrayResize(alerts, newSize);
      size = newSize;
   }
   
   ArrayResize(alerts, size + 1);
   alerts[size] = time;
}
void checkBreakouts()
{

   for (int i = 2; i < Bars; i++)
   {
      if (i + 1 >= Bars)
         continue;


      int lastSupportBar = MathMin(i + MaxSupportLookback, Bars - 1);
      double priorSupport = Low[i + 1];
      for (int j = i + 1; j <= lastSupportBar; j++)
      {
         if (Low[j] < priorSupport)
            priorSupport = Low[j];
      }


      if (Low[i] < priorSupport && Close[i - 1] > High[i])
      {
         datetime rejectTime = Time[i - 1];
         if (!IsAlertSent(rejectTime))
         {
            string msg = "Breakout (breakdown+rejection) on " + Symbol() + " at " +
                         TimeToStr(rejectTime, TIME_DATE | TIME_MINUTES);
            if (EnableAlerts)
               Alert(msg);
            Print(msg + " priorSupport=" + DoubleToStr(priorSupport, Digits));


            ClearPreviousBreakoutLines();

            string rejectLine = "BreakoutReject_" + TimeToStr(rejectTime, TIME_SECONDS);
            ObjectCreate(0, rejectLine, OBJ_HLINE, 0, 0, Close[i - 1]);
            ObjectSetInteger(0, rejectLine, OBJPROP_COLOR, Green);
            ObjectSetInteger(0, rejectLine, OBJPROP_WIDTH, 2);
            ObjectSetInteger(0, rejectLine, OBJPROP_STYLE, STYLE_DASH);
            
            SendNotification("Breakout " + Symbol() + " " + TimeframeToString() + " on " + TimeToStr(Time[i]));

            AddAlert(rejectTime);
         }
         break; 
      }
   }
}
   
   
   
//-----------------------
// Pattern Detection
//-----------------------

bool IsBearishEngulfing(int i)
{
   if (i + 1 >= Bars) return false;

   return (
      Close[i] < Open[i] &&                       // current candle is bearish
      Close[i + 1] > Open[i + 1] &&               // previous candle is bullish
      High[i] >= High[i + 1] + Point * 2 &&       // high fully engulfs
      Low[i] <= Low[i + 1] - Point * 2 &&         // low fully engulfs
      Close[i] < Low[i + 1] - Point * 2           // closes below prior candle's low
   );
}

bool IsBullishEngulfing(int i)
{
   if (i + 1 >= Bars) return false;

   return (
      Close[i] > Open[i] &&                       // current candle is bullish
      Close[i + 1] < Open[i + 1] &&               // previous candle is bearish
      Low[i] <= Low[i + 1] - Point * 2 &&         // low fully engulfs
      High[i] >= High[i + 1] + Point * 2 &&       // high fully engulfs
      Close[i] > High[i + 1] + Point * 2          // closes above prior candle's high
   );
}

bool HasBullishRSIDivergence(int i)
{
   if (i + 5 >= Bars) return false;

   double currentLow = Low[i];
   double prevLow = Low[i + 5];

   double rsiCurrent = iRSI(NULL, 0, RSI_Period, PRICE_CLOSE, i);
   double rsiPrev = iRSI(NULL, 0, RSI_Period, PRICE_CLOSE, i + 5);

   return (
      currentLow < prevLow - Point * 2 &&   
      rsiCurrent > rsiPrev + 0.1            
   );
}

//-----------------------
// Draw Helper
//-----------------------

void DrawBlackLine(string name, datetime time)
{
      DeleteAllLines();
   if (ObjectFind(0, name) < 0)
   {
      ObjectCreate(0, name, OBJ_VLINE, 0, time, 0);
      ObjectSetInteger(0, name, OBJPROP_COLOR, clrBlack);
      ObjectSetInteger(0, name, OBJPROP_WIDTH, 2);
   }
}
void ClearPreviousBreakoutLines()
{
   for (int i = ObjectsTotal() - 1; i >= 0; i--)
   {
      string name = ObjectName(i);
      if (StringFind(name, "BreakoutReject_") >= 0 || StringFind(name, "BreakoutReject_") >= 0)
         ObjectDelete(0, name);
   }
}


void DeleteAllLines()
{

   for(int i = ObjectsTotal() - 1; i >= 0; i--)
   {
      string objName = ObjectName(i);
      if(StringFind(objName, "EngulfInvalid_") >= 0 || 
         StringFind(objName, "BullishRSIEngulf_") >= 0
       )
      {
         ObjectDelete(0, objName);
      }
   }
}
